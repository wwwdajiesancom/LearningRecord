2.类型与运算
	2.1变量与常量
		常量：程序中固定不变的值。
		
		常量的分类：
			1.定义值常量，使用了final关键字；例子：final int i1 = 123;//i1就是定义的常量
			2.字面值常量，就是一些直接输出的值（可以是整数、小数、true、false等）；例子：System.out.println(123);//其中的123就是字面常量
		
		变量的定义：
			为什么要有变量呢？例子：租房合同，如果不用变量的话，有很多的地方需要签名的；但如果用了，可以声明：房东=甲方，租户=乙方，在其它地方都用甲方、乙方来代表。
			这就是最原始的变量，因为有这样的需求，所有就会衍生出变量的定义。
			
			变量的特点：
				1.占据了一定的内存空间
				2.该空间存在了名称（变量名称）、类型
				3.该空间里存放的值可变在一定的范围内
				4.可以被重复的利用
				
			变量名称定义：
				它由字母、数字、下划线组成；不能以数字开头
				
			变量的作用域：
				变量分类：根据变量所在的位置不同，可分：
					１．成员变量，因为它在类中，所以直接作用在整个类
					２．局部变量，他在方法中，所以只能在本方法中有效
				
			
	2.2数据基本类型
		
	2.3数据类型之间的转换
		
	2.4运算符
		



16.数据结构
	概念：
		数据结构是（计算机存储数据、组织数据的方式）
		数据结构是（指相互之间在一种或多种特定关系的数据元素的集合）
		通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同搞笑的检索算法和索引技术有关。
	作用：
		1.模拟生活中数据的存储
		2.作为程序员开发的工具
	
	常见的数据结构：
		数组(Array)，
		栈(Stack)，
		链表(Linked List)，
		哈希表(Hash)，
		队列(Queue)，
		堆(Heap)，
		图(Graph)，
		树（Tree）
		
	常用的数组操作：
		Arrays中的方法,
		System.copy
		
	性能分析(CRUD)：
		Array,数组集合,里面存放了一个数组
			插入，（最后一位插入，第一位插入[后面的都需要移位,可能需要扩容]，平均是[N+1]/2）
			删除，（删除最后一位，删除第一位[都需要向前移动一位]，平均是[N+1]/2）
			修改，（可以直接修改，改动一位1）
			查询，（根据下标,1位,根据内容,[N+1]/2）
		
		Linked List,链表集合,链表中有节点的概念，Node{
									Node prev;//前面一个元素
									Object eleData;//数据
									Node next;//后面一个元素
								}
			插入，（第一个，最后一个，中间插入，[1+1+N+1]/3）
			删除，（）
			修改，（）
			查询，（）
		
		Queue,队列：
			概念：队列是一种特殊的线性表，特殊之处在于它只允许在表的前端(front)进行删除，在表的后端(rear)进行插入，
				和栈一样，队列是一种操作受限制的线性表。
				
			单向队列(Queue):先进先出,后进后出(FIFO[first in first out])
			双向队列(Deque):可以从两端插入及输出,(double enable queue)
			
		Stack,栈：
			概念；又名堆栈，它是一种运算受限的线性表，特点后进先出(LIFO[last in first out])
				其限制是仅允许在表的一端进行插入和删除运算。这一端被成为栈顶，相对的，把另一端称为栈底
				向栈里面插入数据，叫做入栈、压栈；删除数据叫做出栈、退栈
		
		Hash:
			如果数组中的元素与下标存在对应的关系，这样的数组就成为Hash表、散列表
			Hash是通过数组、链表组成的；
			
17.容器
	为什么要存在容器，容器可以存储多个数据元素，但是数组也可以存放多个数据元素呀，通过以下的分析可以知道：
		数组的弊端：
			1.数组定义好之后，长度就被固定了
			2.数组不能体现封装的概念，你每写一个数组，要实现相同的功能都需要重新在写一遍
			3.即使大家都封装了对数组的操作类，但是它不统一，这导致很多的问题
			
	什么是集合框架：
		集合框架是表示和操作集合而规定的一种统一的标准体系结构。
		大块内容可分为3部分：
			1.定义了对外的接口，
			2.都有接口的实现类，
			3.有统一的集合算法
	
	常用的集合有：
		List:有序的、可重复的集合
		Map:一组无序的键值对，其中的key不可重复，值可以重复
		Set:无序的、不可重复的集合
		
	17.1.Vector
		Vector,它实现了Collection接口
			它是线程安全的
			底层的数据结构是一个Object[]数组,
			
	17.2.Stack extends Vector
		Stack,栈，实现类:
		底层可以通过Object[]数组或链表实现
	
	17.3.ArrayList
		它与Vector相比，它是线程不安全
		如果在多线程中使用List，也不需要用Vector，使用Collections.synchronizedList(List.class);
		从jdk1.7之后它的源码与Vector差别就比较大了,例如Vector初始时Object[]长度为10,而ArrayList的为0
	
	17.4.LinkedList,它是实现了Deque,List等接口；还实现了栈(Stack)的操作
		使用链表实现的List
		使用链表实现的程序，都特别的擅长操作头、尾
		
	17.5.总结上述的对象，
		通过Vector,ArrayList,LinkedList;可以得出它们的共同特征就是（都可以存放有序的、可重复的数据元素），所以它们可以抽象出一个List接口，作为它们共用的规范；
		同时，队列Queue也可以用LinkedList来实现；
		Stack栈，可以用Vector来实现了；
		可以存放无序、不可重复的数据元素，被我们抽象成Set,
		那Set,List,Queue就可以共同的抽象成了Collection了
		
	17.6.迭代器
		Iterator,里面有Object next()，boolean hasNext();但是它仅仅只可以单向的向后遍历；
		ListIterator,可以双向的迭代，一般不用；
		Enumeration,这个是jdk1.2之前的；现在基本不用了，了解即可。
		
		常见的问题是，使用迭代的时候删除元素，不能使用集合的remove方法（会出现并发修改异常），
		需要用迭代的remove方法（可以从两个线程中都清楚了数据）
		
	17.7.泛型（Generic）
		为什么用用泛型呢？
			1.因为在集合中，存放的都是Object的数据类型，在取出的时候就必须强制转换类型了，
				但是你不一定知道它是什么类型呀（因为Set它是无序的），这样就导致问题的出现，从而出现了泛型
			2.集合定义了泛型后，可以约束向集合中添加的元素
			
		什么是泛型：
			所谓泛型，即通过参数化类型来实现在同一份代码上操作多种数据类型，泛型
			编程是一种变成范式，它利用"参数化类型"将类型抽象化，从而实现更为灵活的复用。
			1.可以被广泛使用的类型（可以代表其它的类型）
			2.代码中不确定的类型，就可以用泛型，在实例化时才去定义数据类型
			3.泛型就是类型参数化
		泛型常用的：
			T:Type
			E:Element
			K:Key
			V:Value
			
		泛型的通配符及上线、下线：
			?:List<?> list;这个list只能当作一个接收对象使用，并不能向里面添加东西；
			? extends Object,
			? super Number可以有这两种写法，分别代表的下线，上线
			
		泛型的擦除与转换：
			1.在定义过后，编译成功之后，就没有泛型了
			2.已经定义的好，赋值给定义的对象（该对象没有声明泛型。例如：List<Integer> list1 = new ArrayList<>();List list = list1;）这样就将泛型都去掉了
			
		堆污染：一般在用到泛型的时候会出现这种问题，一般都是在泛型、可变参数的时候会出现
			
	
18.Set
	18.1.Set集合的特点：
		1.不允许有重复元素
		2.集合中的元素没有记录下标，意味着无序
		
	18.2.HashSet，它是Set下常用的子类
		他用到了Hash算法，底层有的是HashMap
		
		
	18.3.Map
		Map底层用的是数组，链表；根据键的hash算出在数组中的下标,如果下标中已经存放了数据，就存放成链表结构。
		
		映射，在数学中的概念：
			设A、B是两个非空集合，如果存在一个法则f,使得A中的每一个元素在B中都有唯一的元素对应，则称：
			f:A-->B;
			
		随之映射关系（两个集合）：A集合、B集合
			A集合中的每一个元素都可以在B集合中找到唯一的一个与之对应的值
			
		严格的来讲Map并不是集合，而是两个集合之间的映射（Map并没有继承Collection），Entry
		Map中的键（Key）是不能重复的,所以会有一个keySet()方法=java.util.Set；
		Map中的值（Value）是可以重复的，所有有一个values()方法=java.util.Collection
		Map中的键值对Entry,不可重复,所以有一个entrySet()方法=java.util.Set
		
		Hashtable,实现了Dictionary
		Properties,它是Hashtable的子类，里面存放的都是字符串键值对
		
			
19.IO
	1.File,操作文件/目录的属性类
		
	
	2.什么是IO：输入/输出(Input/Output)
		自定义名称：
			有数据的可以叫做源泉；
			存放数据的可以叫做目标；
			它们直接的运输过程可以相对的叫做输出，输入，也叫管道；
			中间运输的最小单位是：字节、字符
		
	3.流的划分：
		1.根据流的流动方向分为：输出流、输入流
		2.根据流的单位分为：字节流、字符流
		3.根据流的功能分为：节点流、包装流
		
		流基本有4大类：
			字节输入流：OutputStream
			字节输出流：InputStream
			
			字符输入流：Reader
			字符输出流：Writer
			
		流操作的步骤：
			读进来，写出去（读进程序，写到其它地方）
			具体的解析[写出去]：
				1.创建目标对象，也就是要输出的对象【可以是文件File、字节数组byte[]等】
				2.创建输出管道(OutputStream,Writer)
				3.输出信息【方法有3，write(int b)输出单个字节、write(byte[] b)输出一个字节数组、write(byte[] b,int off,int len)从字节数组b中输出部分，off作为开头，len作为长度】
				4.关闭管道【close()】
			具体的解析[读进来]:
				1.创建目标对象，也就是要输入的对象【可以是文件File、字节数组byte[]等】
				2.创建输入管道(InputStream,Reader)
				3.输入【方法有3,int bytes = read()读取一个字节、int len = read(byte[] bytes)读取多个字节、】
				4.关闭管道【close()】
			
		都有那些流操作呢：
			1.文件流
				文件字节输入流：FileInputStream
				文件字节输出流：FileOutputStream
				文件字符输入流：FileReader
				文件字符输出流：FileWriter
		
22.反射
		
23.网络变成
	1.URLEncoder
	2.TCP三次握手(必须连接)；UDP面向非连接的
			
24.JAVA5、JAVA7的特性
	24.1.静态引入(import static java.lang.Math.PI;import static java.lang.Math.*),
		这样在下面的类中就可以随意的直接使用Math中的静态方法、常量。
		静态引入，当我们编译过后会发现，类的引用又被加上了；所以静态引入仅仅是为了方便
		我们书写，并不存在这种用法，不推荐使用。
	24.2.可变参数，实质是传递的数组，通过编译后的代码可以得知。
	24.3.foreach,这种方式编译过后，又变成了for了
	24.4.自动装箱与拆箱，(-128--127)享元设计(缓存),代表了同一个对象
	24.5.泛型，
			
			
			
25.JAVA8的特性		
	25.1.lambda表达式（它是一种简写，省略的代码由java编译器补上）
		lambda表达式，主要是为省略一些抽象类或接口实现匿名类的写法而设立的；如下：
		Runnable r = new Runnable(){
			public void run(){
				System.out.println("jiegehao");
			}
		};
		new Thread(r).start();
		Comparator<T> c = new Comparator<T>(){
			public int compare(T o1,T o2){
				return Integer.compare(o1.column1,o2.column1);
			}
		};
		Arrays.sort(T[] t,c);
		以上使我们常用的写法，但是如果用了lambda表达式就可以这样写了
		Runnable r = () -> System.out.println("jiegehao");
		Comparator<T> c = (o1,02) -> Integer.compare(o1.column1,o2.column1);
		lambda表达式,就是将一切可省略的都去掉，当然实现体部分也可以是一个{}块；
		
	25.2.函数式接口：他算是更近一步了，将抽象接口省略成一个其它类的方法，这叫做方式引用
		我们将接口/抽象类中只有一个抽象方法的类叫做函数式接口，这样的接口都可以用lambda表达式来写。
		我也可以添加标签@FunctionalInterface，它可以做为检查，也可以作为一个标识
		只有一个抽象方法的理解，是包括除了Object中的方法
		函数式接口可以写Object中的方法
		Integer::compare，这种写法叫做方法引用，也用于lambda表达式
		Comparator<Integer> c = Integer::compare;
		lambda表达式的运用：方法引用的方式：
			第一种：静态对象::静态方法
			第二种：实例化对象::方法
			
	25.3.lambda表达式的运用：构造方法引用
		ArrayList::new
	
	25.4.接口中的默认方法
	interface Animal{
		
		default void noSys{
			system.out.pritnln("都不会说话");
		}
		
		void a();
		
	}
	当接口中可以有方法之后，就会出现问题，会出现在extends,implements共同出现，这样就会出现冲突现象，此时必须重写这个方法，
	ClassName.super.methodName();